//
//  InvestmentPresenterTests.swift
//  SantanderExample
//
//  Created by Luan Henrique Damasceno Costa on 13/05/2018.
//  Copyright (c) 2018 Luan Henrique Damasceno Costa. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

@testable import SantanderExample
import XCTest
import Moya

class InvestmentPresenterTests: XCTestCase
{
  // MARK: Subject under test
  
  var sut: InvestmentPresenter!
  var fundResponse: InvestmentFundResponse!
  
  // MARK: Test lifecycle
  
  override func setUp() {
    super.setUp()
    setupInvestmentPresenter()
  }
  
  override func tearDown() {
    super.tearDown()
  }
  
  // MARK: Test setup
  
  func setupInvestmentPresenter() {
    sut = InvestmentPresenter()
  }
  
  // MARK: Test doubles
  
  class InvestmentDisplayLogicSpy: InvestmentDisplayLogic {
    var displayGetInvestmentCalled = false
    var displayErrorCalled = false
    
    var viewModel: Investment.GetInvestment.ViewModel!
    
    func displayInvestment(viewModel: Investment.GetInvestment.ViewModel) {
      displayGetInvestmentCalled = true
      self.viewModel = viewModel
    }
    
    func displayError(title: String, message: String) {
      displayErrorCalled = true
    }
  }
  
  class InvestmentWorkerSpy: InvestmentWorker {
    var fundResponse: InvestmentFundResponse!
    
    func mockProvider() {
      provider = MoyaProvider<InvestmentTargetType>(stubClosure: MoyaProvider.delayedStub(1))
    }
    
    func fetchFundResponse(expectation: XCTestExpectation) {
      mockProvider()
      getInvestment(onSuccess: { (fundResponse: InvestmentFundResponse) in
        self.fundResponse = fundResponse
        expectation.fulfill()
      }) { (error) in
        XCTFail("Fail getting fund response")
        expectation.fulfill()
      }
    }
  }
  
  // MARK: Tests
  
  func testFetchInvestmentFormatScreen() {
    // Given
    let spy = InvestmentDisplayLogicSpy()
    let workerSpy = InvestmentWorkerSpy()
    
    sut.viewController = spy
    
    let expect = expectation(description: "Wait for getInvestment() to return")
    workerSpy.fetchFundResponse(expectation: expect)
    waitForExpectations(timeout: 1.1)
    
    fundResponse = workerSpy.fundResponse
    
    XCTAssertNotNil(fundResponse.screen, "Error parsing object")
    let screen = fundResponse.screen
    
    // When
    let viewModel = sut.mountInvestmentScreen(investment: screen!)
    
    XCTAssertGreaterThan(viewModel.mainInformation.title.count, 0, "Main information not generated properly.")
    XCTAssertGreaterThan(viewModel.mainInformation.definition.count, 0, "Main information not generated properly.")
    XCTAssertGreaterThan(viewModel.mainInformation.whatIs.count, 0, "Main information not generated properly.")
    XCTAssertGreaterThan(viewModel.mainInformation.infoTitle.count, 0, "Main information not generated properly.")
    XCTAssertGreaterThan(viewModel.mainInformation.lastYearCDI.count, 0, "Main information not generated properly.")
    XCTAssertGreaterThan(viewModel.mainInformation.lastYearFund.count, 0, "Main information not generated properly.")
    XCTAssertGreaterThan(viewModel.mainInformation.yearCDI.count, 0, "Main information not generated properly.")
    XCTAssertGreaterThan(viewModel.mainInformation.yearFund.count, 0, "Main information not generated properly.")
    XCTAssertGreaterThan(viewModel.mainInformation.monthCDI.count, 0, "Main information not generated properly.")
    XCTAssertGreaterThan(viewModel.mainInformation.monthFund.count, 0, "Main information not generated properly.")
    XCTAssertGreaterThan(viewModel.mainInformation.riskTitle.count, 0, "Main information not generated properly.")
    
    XCTAssertGreaterThan(viewModel.riskCollectionModels.count, 0, "Main information not generated properly.")
    
    XCTAssertGreaterThan(viewModel.informationTableModels.count, 0, "information cells must be greater than 0")
    
    let riskSelected = viewModel.riskCollectionModels.filter { (cell) -> Bool in
      return cell.isSelected
    }
    
    XCTAssertEqual(riskSelected.count, 1, "Must have only one cell with risk selected.")
  }
  
  func testPresentFetchedInvestmentShouldAskViewControllerToDisplayInvestment() {
    let spy = InvestmentDisplayLogicSpy()
    sut.viewController = spy
    fundResponse = InvestmentFundResponse()
    
    let response = Investment.GetInvestment.Response(fundResponse: fundResponse)
    
    sut.presentFetchedInvestment(response: response)
    
    // Then
    XCTAssertTrue(spy.displayGetInvestmentCalled, "fetchInvestment(response:) should ask the view controller to display the result")
  }
}
